\chapter{关系模型}

\begin{introduction}[期末考试提纲]
    \item 笛卡尔积
    \item 关系模型三要素
    \item 关系模型的完整性
    \item 全关系系统的十二条准则
    \item 关系运算
    \item 元组演算表达式
    \item 域关系演算表达式
    \item 用关系代数表达关系数据操作
\end{introduction}

\section{关系基本概念}

\begin{definition}[域(Domain)]
具有相同数据类型的一组值的集合.
如整数集合、字符串集合、全体学生集合.
\end{definition}

\begin{definition}[笛卡尔积(Cartesian Product)]
一组域$D_1,D_2,...,D_n$的\textcolor{red}{笛卡尔积}为:
\begin{align*}
    D_1\times D_2\times \cdots\times D_n = \{(d_1,d_2,...,d_n)|d_i\in D_i, i=1,2,...,n\}.
\end{align*}
笛卡尔积的元素$(d_1,d_2,...,d_n)$称作$n$元组(tuple).

元组的每一个值$d_i$被称作分量(component).

若$D_i$的基数为$m_i$, 则笛卡尔积的基数为$\prod_{i=1}^{n}m_i$.
\end{definition}

\begin{definition}[关系]
笛卡尔积$D_1\times D_2\times \cdots\times D_n$的子集称作在域$D_1,D_2,...,D_n$上的\textcolor{red}{关系}. 用$R(D_1,D_2,...,D_n)$表示. $R$是关系的名字, $n$是关系的度或目.

关系是笛卡尔积中\textcolor{red}{有意义}的子集.
\end{definition}

关系的性质:
\begin{enumerate}
    \item $P_1$: 列是同质的, 是同一类型的数据, 即每一列中的分量来自同一域.
    \item $P_2$: 不同的列可以来自同一域, 每列必须有不同的属性名. (一元联系、类型相同的属性)
    \item $P_3$: 行列的顺序无关紧要.
    \item $P_4$: 任意两个元组不能完全相同 (集合内不能有相同的两个元素)
    \item $P_5$: 每一分量必须是不可再分的数据, 称其为作满足第一范式(1NF)的关系. 
\end{enumerate}

\section{关系模型三要素}

关系模型的三要素:
\begin{enumerate}
    \item 数据结构.
    \item 数据操作.
    \item 数据完整性.
\end{enumerate}

\subsection{数据结构}

关系模型的数据结构就是\textcolor{red}{关系}: 实体集和联系都表示为关系.

\begin{definition}[候选码(Candidate Key)]
关系中的一个属性组, 其值能唯一标识一个元组. 
若从属性组去掉任何一个属性, 它就不具有这一性质了, 这样的属性组称为候选码.
\end{definition}

\begin{definition}[主属性]
任何一个候选码中的属性被称为主属性.
\end{definition}

\begin{definition}[主码(Priamry Key, PK)]
进行数据库设计时, 从一个关系的多个候选码中选定一个作为主码.
\end{definition}

\begin{definition}[外码(Foreign Key, FK)]
关系$R$中的一个属性组, 它不是$R$的码, 但它与另一个关系$S$的码相
对应, 称这个属性组为$R$的外码.
\end{definition}

\begin{definition}[关系模式]
关系的描述, 记为$R(A_1,A_2,...,A_n)$, 包括:
\begin{enumerate}
    \item 关系名、关系中的属性名.
    \item 属性向域的映像, 通常说明为属性的类型、长度等.
    \item 属性间的数据依赖关系, 比如在特定的时间和教室只能安排一门课.
\end{enumerate}
关系模式是稳定的.
\end{definition}

\begin{definition}[关系]
关系是某一时刻对应某个关系模式的内容(元组的集合). 关系是某一时刻的值, 是随时间不断变化的.
\end{definition}

\begin{definition}[关系型数据库]
\begin{enumerate}
    \item 型: 关系模式的集合, 数据库描述. 数据库的内涵(Intension).
    \item 值: 是某一时刻关系的集合. 数据库的外延(Extension).
\end{enumerate}
\end{definition}

\subsection{数据操作}

关系操作是集合操作. 操作的对象及结果都是集合. 是一次一集合 (Set-at-a-time)的方式.

非关系型的数据操作方式是一次一记录(Record-at-a-time).

关系数据语言的特点:
\begin{enumerate}
    \item 一体化: 对象单一, 都是关系, 因此操作符也单一
    \item 非过程化: 用户只需提出“做什么” , 无须说明“怎么做”. 存取路径的选择和操作过程由系统自动完成
    \item 面向集合的存取方式: 一次一关系.
\end{enumerate}

抽象的关系模型查询语言:
\begin{enumerate}
    \item 关系代数. 过程查询语言.
    \item 关系演算: 元组关系演算、域关系演算. 非过程查询语言.
\end{enumerate}

SQL(介于关系代数和关系验算之间, by IBM)、QUEL(基于 Codd 提出元组关系演算语言ALPHA)、QBE.

\subsection{数据完整性}

\begin{definition}[关系模型完整性]
关系模型完整性由三部分组成:
\begin{enumerate}
    \item 实体完整性
    \item 参照完整性
    \item 用户定义完整性
\end{enumerate}
\end{definition}

\begin{definition}[实体完整性]
关系的主码中的属性值不能为空值. (保证其实体存在.)
\end{definition}

\begin{definition}[参照完整性]
如果关系$R_2$的外码$F_k$与关系$R_1$的主码$P_k$相对应, 
则$R_2$中每个元组的$F_k$值或者等于$R_1$中某个元组的$P_k$值, 或者为空值.

如果关系$R_2$的某个元组$t_2$参照了关系$R_1$的某个元组$t_1$, 则$t_1$必须存在, 
也即必须与客观存在的实体发生联系.
\end{definition}

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{./figure/参照完整性.pdf}
    \caption{参照完整性}
\end{figure}

\begin{definition}[用户完整性]
用户针对具体应用环境定义的完整性约束条件.
\end{definition}

实体完整性和参照完整性由系统自动支持, 系统提供定义和检验用户定义的完整性的机制.

\section{关系代数运算}

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{./figure/关系代数.pdf}
\end{figure}

\subsection{基本关系代数运算}

\subsubsection{一元运算}

\begin{definition}[选择运算]
在关系中选择给定条件的元组(行角度):
\begin{align*}
    \sigma_F(R)=\{t|t\in R,F(t)=\text{true}\}.
\end{align*}
$F$由逻辑运算符连接算术表达式而成.
\end{definition}

\begin{definition}[投影运算]
从关系中取若干列组成新的关系(从列的角度):
\begin{align*}
    \Pi_A(R) = \{t[A]|t\in R\}, A \subseteq R.
\end{align*}
\end{definition}

投影的结果要去掉相同的行:
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{./figure/投影.pdf}
    \caption{投影运算要去掉相同的行}
\end{figure}

\begin{definition}[更名运算]
将关系$R$更名为$S: \rho_S(R)$; 将计算表达式$E$更名为关系$S: \rho_{S(A_1,A_2,...,A_n)}(E)$.
\begin{enumerate}
    \item 将更名运算施加到关系上, 得到具有不同名字的同一关系
    \item 当同一关系多次参与同一运算时需要更名
\end{enumerate}
\end{definition}

\subsubsection{多元运算}

\begin{definition}[并运算]
\begin{align*}
    R\cup S =\{r|r\in R\lor r \in S\}.
\end{align*}
关系$R$和$S$进行并运算的前提是它们必须是相容的.
\begin{enumerate}
    \item 关系$R$和$S$必须是同元的, 其属性数目必须相同.
    \item 对$\forall i$, $R$的第$i$个属性和$S$的第$i$个属性的域必须相同.
\end{enumerate}
\end{definition}

\begin{example}
选修了001号或002号课程的学生号.
\begin{align*}
    &\Pi_{\text{sno}}(\sigma_{\text{cno}=001\lor \text{cno}=002}(\text{SC})) \\
    &\Pi_{\text{sno}}(\sigma_{\text{cno}=001}(\text{SC})\lor \sigma_{\text{cno}=002}(\text{SC}))
\end{align*}
\end{example}

\begin{definition}[差运算]
\begin{align*}
    R-S =\{r|r\in R\land r \not\in S\}.
\end{align*}
\end{definition}

\begin{example}
求选修了001号但未选修002号课程的学生号.
\begin{align*}
    &\Pi_{\text{sno}}(\sigma_{\text{cno}=001}(\text{SC})) - \Pi_{\text{sno}}(\sigma_{\text{cno}=002}(\text{SC})) \\
   &\Pi_{\text{sno}}(\sigma_{\text{cno}=001\lor \text{cno}\neq 002}(\text{SC}))
\end{align*}
\end{example}

\begin{definition}[连串(Concatenation)]
$r=(r_1,r_2,...,r_n)$, $s=(s_1,s_2,...,s_m)$, $r$与$s$的连串定义为:
\begin{align*}
    \widehat{rs} = (r_1,r_2,...,r_n,s_1,s_2,...,s_m).
\end{align*}
\end{definition}

\begin{definition}[笛卡尔积]
\begin{align*}
    R\times S=\{\widehat{rs}|r\in R\land s\in S\}.
\end{align*}
\begin{itemize}
    \item $R\times S$的度为$R$和$S$的度之和.
    \item $R\times S$的元组个数为$R$和$S$的元组个数之积.
\end{itemize}
\end{definition}

\begin{example}
求选修c1课程的学生姓名.
\end{example}

\begin{figure}[H]
    \centering
    \includegraphics[width=.75\textwidth]{./figure/笛卡尔积的使用.pdf}
    \caption{笛卡尔积的使用}
\end{figure}

\begin{example}
求数学成绩比王红同学高的学生姓名.
\end{example}
\begin{align*}
    \Pi_{S.\text{姓名}}\left(\sigma_{R.\text{姓名}=\text{王红}\land R.\text{课程}=\text{数学}\land S.\text{课程}=\text{数学} \land R.\text{成绩} < S.\text{成绩}} (R\times \rho_S(R))\right)
\end{align*}

\subsection{扩展关系代数运算}

\begin{definition}[交运算]
\begin{align*}
    R\cap S =\{r|r\in R\land r \in S\}.
\end{align*}
$R\cap S = R-(R-S)$.
\end{definition}

\begin{example}
求同时选修了001号和002号课程的学生号.
\end{example}
\begin{align*}
    &\Pi_{\text{sno}}(\sigma_{\text{cno}=001}(\text{SC})) \cap \Pi_{\text{sno}}(\sigma_{\text{cno}=002}(\text{SC})) \\
    &\Pi_{\text{sno}}(\sigma_{\text{cno}=001\land \text{cno}=002}(\text{SC}))
\end{align*}

\begin{definition}[$\theta$连接]
从两个关系的广义笛卡儿积中选取给定属性间满足一定条件的元组:
\begin{align*}
    R \underset{{A\theta B}}{\bowtie} S = \{\widehat{rs}|r\in R \land s \in S \land r[A]\theta s[B]\}
    = \sigma_{r[A]\theta s[B]}(R\times S).
\end{align*}
\end{definition}

$A,B$为$R$和$S$上度数相等且可比的属性列, $\theta$为算术比较符.

\begin{example}
求数学成绩比王红同学高的学生姓名.
\end{example}
\begin{align*}
    \Pi_{S.\text{姓名}}\left(\sigma_{\text{课程}=\text{数学}\land \text{姓名}=\text{王红}}(R) \underset{R.\text{成绩}<S.\text{成绩}}{\bowtie}\sigma_{\text{课程}=\text{数学}}\rho_S(R)\right)
\end{align*}

\begin{definition}[等值连接]
$\theta$为等号的时候为等值连接.
\end{definition}

\begin{definition}[自然连接]
从两个关系的广义笛卡儿积中选取在相同属性列$B$上取值相等的元组, 并去掉重复的列:
\begin{align*}
    R \bowtie S = \{ \widehat{rs}[\bar{B}] | r \in R \land s \in S \land r[B]=s[B] \}.
\end{align*}
自然连接与等值连接不同: 自然连接中相等的分量必须是相同的属性组, 并且要在结果中去掉重复的属性, 而等值连接则不必.
\end{definition}

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{./figure/自然连接.pdf}
    \caption{自然连接例子}
\end{figure}

\begin{example}
求出001号学生所在系的名称:
\begin{align*}
    &\Pi_{\text{dname}}(\sigma_{\text{sno}=001}(S\bowtie \text{Dept})) \\
    &\Pi_{\text{dname}}(\sigma_{\text{sno}=001}(S)\bowtie \text{Dept})
\end{align*}
\end{example}

\begin{example}
关系$R(A,B)$, $S(A,C)$, $R$与$S$中元组个数分别为10, 15, 试填写下表.
\end{example}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
条件 & 表达式 & 最小元组数 & 最大元组数 \\ \hline
\multirow{2}{*}{无任何条件} & $R \bowtie S$ & 0 & 150 \\ \cline{2-4}
 & $\Pi_A(R) \cup \Pi_A(S)$ & 1 & 25 \\ \hline
\multirow{2}{*}{A是R的主码} & $R \bowtie S$ & 0 & 15 \\ \cline{2-4}
 & $\Pi_A(R) \cup \Pi_A(S)$ & 10 & 25 \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}A是R的主码\\ A是S的外码\end{tabular}} & $R \bowtie S$ & 15 & 15 \\ \cline{2-4}
 & $\Pi_A(R) \cup \Pi_A(S)$ & 10 & 10 \\ \hline
\end{tabular}
\caption{不同条件下的表达式及其元组数范围}
\end{table}

自然连接的问题: \textbf{因失配而发生信息丢失}.

\begin{definition}[外连接]
为避免自然连接时因失配而发生的信息丢失, 
可以假定往参与连接的一方表中附加一个取值全为空值的行, 
它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配, 称之为外连接.

外连接 = 自然连接 + 未匹配元组(悬挂元组).

外连接的形式:
\begin{enumerate}
    \item 左外连接 = 自然连接 + 左侧表中未匹配元组. $\leftouterjoin$.
    \item 右外连接 = 自然连接 + 右侧表中未匹配元组. $\rightouterjoin$.
    \item 全外连接 = 左外连接 + 右外连接. $\fullouterjoin$.
\end{enumerate}
\end{definition}

\begin{figure}[H]
    \centering
    \includegraphics[width=.85\textwidth]{./figure/左外连接.pdf}
    \caption{左外连接示意图}
\end{figure}

外连接结合律不成立的反例:
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{./figure/外连接结合律不成立.pdf}
    \caption{外连接结合律不成立的反例}
\end{figure}

\begin{definition}[半连接]
半连接(Semi-join)是一种用于优化查询的操作, 特别是在分布式数据库系统中. 
它主要用于减少数据传输量, 提高查询效率. 
半连接操作的目标是从两个关系(表)中返回第一个关系中的那些元组(行), 
这些元组与第二个关系中的至少一个元组匹配. $\ltimes$.

简单来说, 半连接操作会从一个表(称为外部表或左表)中选择记录, 
并检查这些记录是否在另一个表(称为内部表或右表)中有对应的记录.
如果有, 则保留该记录; 如果没有, 则丢弃. 
但是, 与普通连接不同的是, 结果集只包含来自外部表的列, 而不包含内部表的任何列.
\end{definition}

半连接可以通过 SQL 查询中的 \verb|EXISTS| 或 \verb|IN| 子查询来实现.

\begin{definition}[反半连接]
在半连接操作中, 我们会从第一个表(外部表或左表)中选出那些在第二个表(内部表或右表)中有匹配记录的行. 
而反半连接则恰恰相反, 它的目的是找出那些在第一个表中存在但在第二个表中没有匹配记录的所有行. $\overline{\ltimes}$.
\end{definition}

在SQL中, 反半连接通常可以通过 \verb|NOT EXISTS| 或者 \verb|LEFT JOIN| 加上 \verb|IS NULL| 的方式来实现.

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{./figure/半连接.pdf}
    \caption{半连接示意图}
\end{figure}

\begin{definition}[外部并]
外部并操作的目标是在保持这种兼容性的同时合并这些关系. 
不过, 与内部并(Inner Union)不同, 外部并也会保留那些在其中一个关系中存在但在另一个关系中不存在的属性值.
\begin{align*}
    R \cup_{\text{outer}} S
\end{align*}
\end{definition}

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{./figure/外部并.pdf}
    \caption{外部并示意图}
\end{figure}

\begin{definition}[象集(Image Set)]
    对于关系$R(X,Z)$, $X,Z$是属性组, $x$是$X$上的取值, 定义$x$在$R$中的\textcolor{red}{象集}为:
\begin{align*}
    Z_x = \{t[Z] | t\in R \land t[X]=x\}
\end{align*}
\end{definition}

\begin{remark}
    象集实际是是: (1)先从$R$中选出在$X$上取值为$x$的元组; (2)只保留$Z$属性.
\end{remark}

\begin{example}
如何求得选修了全部课程的学生?
\end{example}

思路一: 判断每个学生的课程象集是否包含了整个课程集合.
\begin{align*}
    \{u|r\in SC \land u=r[\text{姓名}] \land \text{课程名}_u \supseteq C \}
\end{align*}

思路二: 判断学生与课程集合构成的笛卡尔积是否完全包含在选课集合中.
\begin{align*}
    \{u|r\in SC \land u=r[\text{姓名}] \land \forall c\in C, (u,c)\in SC\}    
\end{align*}

\begin{definition}[除法]
除法通常用来找出在第一个关系中与第二个关系中的所有元素都有匹配的那些元组. 它的定义式为:
\begin{align*}
    &R(X,Y) \div S(Y) = \{x|r\in R\land x=r[X] \land Y_x \supseteq S\}, \\
    &R(X,Y) \div S(Y) = \{u|u\in \Pi_X(R) \land \forall v \in S, \widehat{uv} \in R \}.
\end{align*}
除法的计算表达式为:
\begin{align*}
    R(X,Y) \div S(Y) = \Pi_X(R) - \Pi_X(\Pi_X(R)\times \Pi_Y(S) - R).
\end{align*}
\end{definition}

\begin{example}
对于$SC(sno,cno,grade)$, 求选修了所有课程的学生.
\end{example}

\begin{align*}
    \Pi_{sno,cno}(SC) \div \Pi_{cno}(C)
\end{align*}

现在对于除运算中的被除关系要正确投影:

也就是我们考虑下面的两个式子:
\begin{align*}
    &\Pi_{sno,cno}(SC) \div \Pi_{cno}(C)\\
    &\Pi_{sno}(SC\div \Pi_{cno}(C))
\end{align*}

它们对应着下面的图:
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{./figure/除法要求.pdf}
    \caption{对于除运算中的被除关系要正确投影}
\end{figure}

\subsection{关系代数更新运算}

\begin{definition}[赋值运算]
为使查询表达简单、清晰, 可以将一个复杂关系代数表达式分成几个部分, 每一部分都赋予一个临时关系变量, 该变量可被看作关系而在后续表达式中使用.
\begin{align*}
    \text{临时关系变量} \leftarrow \text{关系代数表达式}
\end{align*}
\end{definition}

现在我们可以把对于除法的计算式子写成: 
\begin{align*}
    temp1 \leftarrow &\Pi_X(R) \\
    temp2 &\leftarrow \Pi_X(temp1 \times \Pi_Y(S)-R) \\
    &result \leftarrow temp1 - temp2
\end{align*}

\begin{definition}[广义投影]
    在投影列表中使用算术表达式来对投影进行扩展
    \begin{align*}
        \Pi_{F_1,F_2,\dots,F_n}(E)
    \end{align*}
    其中, $F_1,F_2,\dots,F_n$是算术表达式.
\end{definition}

\begin{example}
    求员工应该缴纳的所得税:
    \begin{align*}
        \Pi_{pno, sal\times 0.05} (PROF)
    \end{align*}
\end{example}

\textbf{数据库修改}: \textcolor{red}{删除}.
\begin{itemize}
    \item 将满足条件的元组从关系中删除, 就是对永久关系的赋值运算, 也就是下面的式子:
    \begin{align*}
        R \leftarrow R - E
    \end{align*}
\end{itemize}

\begin{example}
    删除001号老师所担任的课程.
    \begin{align*}
        PC \leftarrow PC - \sigma_{pno=001}(PC)
    \end{align*}
\end{example}

\begin{example}
    删除没有选课的学生.
    \begin{align*}
        S \leftarrow S - (\Pi_{sno}(S)-\Pi_{sno}(SC)) \bowtie S
    \end{align*}
\end{example}

\textbf{数据库修改}: \textcolor{red}{插入}.
\begin{itemize}
    \item 插入一个指定的元组, 或者插入一个查询结果.
    \begin{align*}
        R \leftarrow R \cup E
    \end{align*}
\end{itemize}

\begin{example}
    加入计算机系学生选修“数据结构”的信息.
    \begin{align*}
        SC \leftarrow SC \cup (\Pi_{sno}(S\bowtie \sigma_{dname = "\text{计算机系}"}(DEPT))\times \Pi_{cno}(\sigma_{name="\text{数据结构}"}(C))\times \{null\})
    \end{align*}
\end{example}

\textbf{数据库修改}: \textcolor{red}{更新}.
\begin{itemize}
    \item 利用广义投影改变元组的某些属性上的值.
    \begin{align*}
        R \leftarrow \Pi_{F_1,F_2,...,F_n}(R)
    \end{align*}
\end{itemize}

\begin{example}
    给每位老师上调10\%的工资.
    \begin{align*}
        PROF \leftarrow \Pi_{pno,pname,sal\times 1.1,dno}(PROF)
    \end{align*}
\end{example}

\section{关系代数查询实例}

\begin{problem}
    求没有选修c1号课程的学生.
\end{problem}
\textit{ 解答. }这样我们需要的求法是: \textcolor{red}{所有学生 - 选修了c1号课程的学生}.
也就是:
\begin{align*}
    \Pi_{sno}(SC) - \Pi_{sno}(\sigma_{cno=c1}(SC)).
\end{align*}

\begin{problem}
    求仅选修了c1号课程的学生号.
\end{problem}
\textit{ 解答. }\textcolor{red}{选修c1号课程的学生 - 仅选c1号课程之外的学生}.
\begin{align*}
    \Pi_{sno}(\sigma_{cno=c1}(SC))-\Pi_{sno}(\sigma_{cno\neq c1}(SC)).
\end{align*}

\begin{problem}
    求选修c1同时又选修其他课程的学生.
\end{problem}
\textit{ 解答. }在SC这个表里排除掉所有的c1记录, 投影一下就得到了除了c1还选了别的课的学生. 那么在选了c1的学生中除去这部分即可.
\begin{align*}
    \Pi_{sno}(\sigma_{cno=c1}(SC))-\Pi_{sno}(SC-\sigma_{cno=c1}(SC)).
\end{align*}

\begin{problem}
    求选修c1课程比s1学生的该门课程成绩高的学生.
\end{problem}
\textit{ 解答. }我们使用两个关系的笛卡尔积, 然后选出$R.grade<S.grade$的元组即可.
\begin{align*}
    \Pi_{S.sno}(\sigma_{R.sno=s1\land R.cno=c1\land R.grade<S.grade}(\rho_R(SC)\times \rho_S(SC))).
\end{align*}

\begin{problem}
    求每门课程的先修课的先修课.
\end{problem}
\textit{ 解答. }我们依然考虑使用笛卡尔积:
\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{figure/先修课.pdf}
    \caption{先修课的先修课}
\end{figure}
那么最后就是:
\begin{align*}
    \Pi_{C.cno,R.pcno}(\sigma_{C.pcno=R.cno}(C\times \rho_R(C))).
\end{align*}

\begin{problem}
    求选修了至少两门课的学生.
\end{problem}
\textit{ 解答. }依然使用笛卡尔积进行一些杂糅, 然后找到里面的$(c1\neq c2)$的元组:
\begin{align*}
    \Pi_{R.sno}(\sigma_{R.sno=S.sno\land R.cno\neq S.cno}(\rho_R(SC)\times \rho_S(SC))).
\end{align*}

\begin{remark}
    如果是“求选修了至少$N$门课的学生”, 应该需要进行$N$次的笛卡尔积.

    如果是“求只选修了1门课的学生”, 只需要\textcolor{red}{选课的学生 - 选修了至少两门课的学生}.
\end{remark}

\begin{problem}
    求最低的成绩.
\end{problem}
\textit{ 解答. }只需要: 使用笛卡尔积, 找到所有的有元组的成绩比它更小的元组, 全体元组减去即可. 剩下的是没有人会比它更小的元组, 也就是最小的元组.
\begin{align*}
    \Pi_{grade}(SC) - \Pi_{S.grade}(\sigma_{R.grade < S.grade}(\rho_R(SC)\times \rho_S(SC))).
\end{align*}

\begin{problem}
    求选修课程中包含了 所有 \textcolor{red}{01号学生所选修课程}的学生号.
\end{problem}
\textit{ 解答. }这种“……包含了……所有……”的形式的题目, 使用除法比较好.
\begin{align*}
    \Pi_{sno,cno}(SC) \div \Pi_{cno}(\sigma_{sno=s01}(SC)).
\end{align*}

\begin{problem}
    求其选修课程被s01号学生所修课程包含的学生号.
\end{problem}
\textit{ 解答. }第一步先利用笛卡尔积找出和s01号学生有选修课程相同的学生, 第二步使用全体选课记录减去这些和s01号选课重叠的部分, 剩下的是不重叠的部分(当然这里包括了s01本身的选课记录). 最后除去不重叠的, 剩下就是完全被s01的选课包含的学生了.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figure/一道题.pdf}
    \caption{问题解答}
\end{figure}

\begin{problem}
    对于关系stock(sno, date, price), 找出一直上涨的股票和上涨过的股票.
\end{problem}
\textit{ 解答. }上涨过的股票: if d1 > d2 then p1 > p2. 从而有:
\begin{align*}
    \Pi_{R.sno}(\sigma_{R.sno=S.sno\land R.date > S.date \land R.price > S.price}(\rho_R(stock) \times \rho_S(stock))).
\end{align*}
现在一直上涨的股票 = 所有的股票 - 下跌的股票. 而下跌过的股票也可以使用上面的方法计算得到.

\begin{problem}
    根据guanxi(source, destination), 找出互相认识的人.
\end{problem}
\textit{ 解答. }使用笛卡尔积, 找到$R.destination = S.source$, 这样就是互相认识的人.

\section{关系演算}

ps. 鉴于PPT里出现了若干次“验算”和若干次“演算”, 下面我统一用“演算”这个词(我没去上课, 不知道正确的这个词的用法如何.)

\subsection{元组关系演算}

\begin{definition}[元组关系演算]
    形式化的定义为$\{t | P(t)\}$, 表示所有使谓词$P$为真的元组集合. 这里的$P$是公式, 由原子公式和运算符组成. 这里的$t$为元组变量, 如果存在全程或者存在量词, 则为约束变量, 否则为自由变量.
\end{definition}

\begin{definition}[原子公式]
    原子公式包括下面的几个公式:
    \begin{itemize}
        \item $s\in R$: $s$是关系$R$的一个元组;
        \item $s[X]\ \theta\ c$: 分量$s[X]$与常量$c$之间满足比较关系$\theta$;
        \item $s[X]\ \theta\ u[Y]$: 分量$s[X]$与分量$u[Y]$之间满足比较关系$\theta$.
    \end{itemize}
\end{definition}

\begin{definition}[公式的递归定义]
    \begin{itemize}
        \item 原子公式是公式;
        \item 若$P$是公式, 则$\neg P$也是公式;
        \item 若$P_1,P_2$是公式, 则$P_1 \land P_2$, $P_1 \lor P_2$, $P_1 \Rightarrow P_2$也是公式;
        \item 若$P(t)$是公式, $R$是关系, 则$\exists t \in R(P(t))$, $\forall t \in R(P(t))$也是公式.
    \end{itemize}
\end{definition}

\begin{example}
    找出工资在800元以上的老师.
    \begin{align*}
        \{t | t \in PROF \land t[SAL] > 800\}.
    \end{align*}
\end{example}

\begin{example}
    找出工资在800元以上的老师的姓名.
    \begin{align*}
        \{t | \exists s \in PROF(t[PNAME]=s[PNAME]\land s[SAL]>800)\}.
    \end{align*}
    这里的$t$实际上只有一个列PNAME!!!!!!
\end{example}

\begin{example}
    给出计算机系老师的姓名.
    \begin{align*}
        \{t | \exists u \in DEPT \exists s \in PROF(u[DNAME]="\text{计算机系}"\land s[DNO]=u[DNO]\land t[PNAME]=s[PNAME])\}.
    \end{align*}
\end{example}

\begin{example}
    求选修了全部课程的学生号.
    \begin{align*}
        \left\{ t \mid \exists u \in S \, \forall v \in C \left( \exists w \in SC \left( v[cno] = w[cno] \land u[sno] = w[sno] \land t[sno] = u[sno] \right) \right) \right\}.
    \end{align*}
\end{example}

\begin{example}
    求选修了s1同学所修全部课程的学生号.
    这句话的意思就是说: 对任意课程, s1选了 $\Rightarrow$ s2也选了.
    \begin{align*}
        \left\{ t \middle| 
            \begin{array}{l}
            \exists u \in S (t[sno] = u[sno]) \land \forall v \in C \\
            \quad \left( \exists w_1 \in SC (w_1[cno] = v[cno] \land w_1[sno] = 's1') \right. \\
            \qquad \implies \left. \exists w_2 \in SC (w_2[cno] = v[cno] \land w_2[sno] = u[sno]) \right)
            \end{array} 
        \right\}
    \end{align*}
\end{example}

元组关系演算与关系代数的等价性:
\begin{itemize}
    \item \textcolor{red}{投影}: $\Pi_A(R) = \left\{ t \mid \exists s \in R (s[A] = t[A]) \right\}$
    \item \textcolor{red}{选择}: $\sigma_{F(A)}(R) = \left\{ t \mid t \in R \land F(t[A]) \right\}$
    \item \textcolor{red}{广义笛卡尔积}: $R(A) \times S(B) = \left\{ t \mid \exists u \in R \, \exists s \in S (t[A] = u[A] \land t[B] = s[B]) \right\}$
    \item \textcolor{red}{并}: $R \cup S = \left\{ t \mid t \in R \lor t \in S \right\}$    
    \item \textcolor{red}{交}: $R \cap S = \left\{ t \mid t \in R \land t \in S \right\}$
    \item \textcolor{red}{差}: $R - S = \left\{ t \mid t \in R \land \neg (t \in S) \right\}$
\end{itemize}

元组关系演算有可能会产生无限关系, 这样的表达式是不安全的. 我们可以人为的定义公式$P$的域的概念, 用$dom(P)$来表示.

\begin{definition}[安全性]
    如果出现在表达式$\{t|P(t)\}$结果中的所有值均来自$dom(P)$, 则称$\{t|P(t)\}$是安全的.
\end{definition}

\subsection{域关系演算}

\begin{definition}[域关系演算]
    形式化定义为$\{\langle x_1, x_2, ..., x_n\rangle | P(x_1, x_2, ..., x_n)\}$. 其中$x_i$代表域变量, $P$为由原子组成的公式.
    \begin{itemize}
        \item $\langle x_1,x_2,...,x_n \rangle \in R$;
        \item $x\,\theta\,c$;
        \item $x\,\theta\,y$;
    \end{itemize}
\end{definition}

\begin{example}
    找出工资在800元以上的老师.
    \begin{align*}
        \{\langle a,b,c,d,e \rangle |\langle a,b,c,d,e \rangle\in PROF \land e > 800 \}.
    \end{align*}
\end{example}

\begin{example}
    找出工资在800元以上的老师的姓名.
    \begin{align*}
        \left\{ \langle b \rangle \mid \exists a, c, d, e (\langle a,b,c,d,e \rangle \in PROF \land e > 800) \right\}
    \end{align*}
\end{example}

\begin{example}
    给出计算机系老师的姓名.
    \begin{align*}
        \left\{ \langle b \rangle \mid \exists l, m, n, s, a, c, d, e (\langle l,m,n,s \rangle \in DEPT \land \langle a,b,c,d,e \rangle \in PROF \land m = \text{“计算机系”} \land l = d) \right\}
    \end{align*}
\end{example}

采用域关系验算的实际查询系统: QBE.

\begin{definition}[包(Bag)]
    允许重复的集合, 或者多集(multi-set).
\end{definition}

\section{关系系统}

\begin{enumerate}
    \item 表式系统: 仅支持关系(即表)数据结构, 不支持集合级操作. 表式系统不能算关系系统.
    \item 最小关系系统: 仅支持关系数据结构和三种关系搡作. 许多微机关系数据库系统如FoxPro属于此类.
    \item 完备关系系统: 支持关系数据结构和所有的关系代数操作. 90年代初的许多关系数据库管理系统属于这一类.
    \item 全关系系统: 这类系统支持关系模型的所有特征.
\end{enumerate}

\subsection{全关系系统的十二条准则}

\begin{itemize}
    \item 准则 0: 一个关系型的DBMS必须能完全通过它的关系能力来管理数据库.
    \item 准则 1: 信息准则. 关系型DBMS的所有信息都应在逻辑一级上用一种方法即表中的值显式地表示.
    \item 准则 2: 保证访问准则. 依靠表名、主码和列名的组合, 保证能以逻辑方式访问关系数据库中的每个数据项(分量值).
    \item 准则 3: 空值的系统化处理. 全关系型DBMS应支持空值概念, 并用系统化的方式处理空值.
    \item 准则 4: 基于关系模型的动态的联机数据字典. 数据库的描述在逻辑级上应该和普通数据采用同样的表示方式, 使得授权用户可以使用查询一般数据所用的关系语言来查询数据库的描述信息.
    \item 准则 5: 统一的数据子语言. 一个关系系统可以有几种语言和多种终端使用方式(如QBE、嵌入式SQL), 但必须有一种语言, 它的语句可以表示为具有严格语法规定的字符串.
    \item 准则 6: 视图更新准则.  所有理论上可更新的视图也应该由系统更新, 即对视图的更新要求, 存在一个算法可以无二义地把更新要求转换为对基本表的更新序列.
    \item 准则 7: 高级的插入、删除和修改操作. 关系系统的操作对象是单一的关系.
    \item 准则 8: 数据物理独立性. 无论数据库的数据在存储表示和存取方法上作任何变化, 应用程序和终端活动都保持逻辑上的不变性.
    \item 准则 9: 数据逻辑独立性. 当对基本关系进行理论上信息不受损害的任何改变时, 应用程序和终端活动都保持逻辑上的不变性.
    \item 准则 10: 数据完整性的独立性. 关系数据库的完整性约束条件必须是用数据库语言定义并存储在数据字典中的, 而不是由应用程序加以定义.
    \item 准则 11: 分布独立性. 分布独立性是指DBMS具有这样的数据库语言, 使得应用程序和终端活动在下列情况下都保持逻辑上的不变性:
    \begin{itemize}
        \item 在第一次引入分布式数据时, 即如果原来的DBMS只管理非分布式的数据, 而现在引入了分布式数据;
        \item 当数据重新分布时, 即如果原来DBMS能管理分布式数据, 现在要改变原来的数据分布.
    \end{itemize}
    \item 准则 12: 无破坏准则. 如果一个关系系统具有一个低级(一次一记录)语言, 则这个低级语言不能违背或绕过完整性准则.
    \begin{itemize}
        \item 为获得完整性的独立性, 需要让完整性约束条件和数据的逻辑结构相独立;
        \item 不能旁路(bypass)或者关闭约束检查子系统.
    \end{itemize}
\end{itemize}
