@book{database,
  author = {亚伯拉罕·西尔伯沙茨 (Abraham Silberschatz) and 亨利. F. 科思 (Henry F. Korth) and S. 苏达尔尚 (S. Sudarshan)},
  publisher = {机械工业出版社},
  title = {数据库系统概念：原书第7版},
  year = {2021},
  edition = {5},
  translator = {杨冬青 and 李红燕 and 张金波},
}
@misc{liApproximateNearestNeighbor2016,
  title = {Approximate Nearest Neighbor Search on High Dimensional Data --- Experiments, Analyses, and Improvement (v1.0)},
  author = {Li, Wen and Zhang, Ying and Sun, Yifang and Wang, Wei and Zhang, Wenjie and Lin, Xuemin},
  year = {2016},
  month = oct,
  number = {arXiv:1610.02455},
  eprint = {1610.02455},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1610.02455},
  urldate = {2025-05-22},
  abstract = {Approximate Nearest neighbor search (ANNS) is fundamental and essential operation in applications from many domains, such as databases, machine learning, multimedia, and computer vision. Although many algorithms have been continuously proposed in the literature in the above domains each year, there is no comprehensive evaluation and analysis of their performances. In this paper, we conduct a comprehensive experimental evaluation of many state-of-the-art methods for approximate nearest neighbor search. Our study (1) is cross-disciplinary (i.e., including 16 algorithms in different domains, and from practitioners) and (2) has evaluated a diverse range of settings, including 20 datasets, several evaluation metrics, and different query workloads. The experimental results are carefully reported and analyzed to understand the performance results. Furthermore, we propose a new method that achieves both high query efficiency and high recall empirically on majority of the datasets under a wide range of settings.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Databases},
}

@misc{malkovEfficientRobustApproximate2018,
  title = {Efficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs},
  author = {Malkov, Yu A. and Yashunin, D. A.},
  year = {2018},
  month = aug,
  number = {arXiv:1603.09320},
  eprint = {1603.09320},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1603.09320},
  urldate = {2025-05-22},
  abstract = {We present a new approach for the approximate K-nearest neighbor search based on navigable small world graphs with controllable hierarchy (Hierarchical NSW, HNSW). The proposed solution is fully graph-based, without any need for additional search structures, which are typically used at the coarse search stage of the most proximity graph techniques. Hierarchical NSW incrementally builds a multi-layer structure consisting from hierarchical set of proximity graphs (layers) for nested subsets of the stored elements. The maximum layer in which an element is present is selected randomly with an exponentially decaying probability distribution. This allows producing graphs similar to the previously studied Navigable Small World (NSW) structures while additionally having the links separated by their characteristic distance scales. Starting search from the upper layer together with utilizing the scale separation boosts the performance compared to NSW and allows a logarithmic complexity scaling. Additional employment of a heuristic for selecting proximity graph neighbors significantly increases performance at high recall and in case of highly clustered data. Performance evaluation has demonstrated that the proposed general metric space search index is able to strongly outperform previous opensource state-of-the-art vector-only approaches. Similarity of the algorithm to the skip list structure allows straightforward balanced distributed implementation.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Computer Vision and Pattern Recognition,Computer Science - Data Structures and Algorithms,Computer Science - Information Retrieval,Computer Science - Social and Information Networks},
}

@article{10.1145/128765.128770,
author = {Mohan, C. and Haderle, Don and Lindsay, Bruce and Pirahesh, Hamid and Schwarz, Peter},
title = {ARIES: a transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging},
year = {1992},
issue_date = {March 1992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {1},
issn = {0362-5915},
url = {https://doi.org/10.1145/128765.128770},
doi = {10.1145/128765.128770},
abstract = {DB2TM, IMS, and TandemTM systems. ARIES is applicable not only to database management systems but also to persistent object-oriented languages, recoverable file systems and transaction-based operating systems.  ARIES has been implemented, to varying degrees, in IBM's OS/2TM Extended Edition Database Manager, DB2, Workstation Data Save Facility/VM, Starburst and QuickSilver, and in the University of Wisconsin's EXODUS and Gamma database machine.},
journal = {ACM Trans. Database Syst.},
month = mar,
pages = {94–162},
numpages = {69},
keywords = {write-ahead logging, space management, locking, latching, buffer management}
}

@Book{ArpaciDusseau23-Book,
  author =       {Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau},
  title =        "{Operating Systems: Three Easy Pieces}",
  publisher =    {Arpaci-Dusseau Books},
  month =        "November",
  year =         {2023},
  edition =      {1.10},
}

@incollection{stonebrakerCstoreColumnorientedDBMS2018,
  title = {C-Store: A Column-Oriented {{DBMS}}},
  shorttitle = {C-Store},
  booktitle = {Making {{Databases Work}}: The {{Pragmatic Wisdom}} of {{Michael Stonebraker}}},
  author = {Stonebraker, Mike and Abadi, Daniel J. and Batkin, Adam and Chen, Xuedong and Cherniack, Mitch and Ferreira, Miguel and Lau, Edmond and Lin, Amerson and Madden, Sam and O'Neil, Elizabeth and O'Neil, Pat and Rasin, Alex and Tran, Nga and Zdonik, Stan},
  editor = {{Massachusetts Institute of Technology} and Brodie, Michael L.},
  year = {2018},
  month = dec,
  edition = {1},
  pages = {491--518},
  publisher = {Association for Computing Machinery},
  doi = {10.1145/3226595.3226638},
  urldate = {2025-06-16},
  abstract = {This paper presents the design of a read-optimized relational DBMS that contrasts sharply with most current systems, which are write-optimized. Among the many differences in its design are: storage of data by column rather than by row, careful coding and packing of objects into storage including main memory during query processing, storing an overlapping collection of columnoriented projections, rather than the current fare of tables and indexes, a non-traditional implementation of transactions which includes high availability and snapshot isolation for read-only transactions, and the extensive use of bitmap indexes to complement B-tree structures.},
  isbn = {978-1-947487-19-2},
  langid = {english},
  file = {D:\zotero-storage\storage\9CSS4V3N\Stonebraker 等 - 2018 - C-store a column-oriented DBMS.pdf}
}

@article{lambVerticaAnalyticDatabase2012,
  title = {The Vertica Analytic Database: {{C-store}} 7 Years Later},
  shorttitle = {The Vertica Analytic Database},
  author = {Lamb, Andrew and Fuller, Matt and Varadarajan, Ramakrishna and Tran, Nga and Vandiver, Ben and Doshi, Lyric and Bear, Chuck},
  year = {2012},
  month = aug,
  journal = {Proc. VLDB Endow.},
  volume = {5},
  number = {12},
  pages = {1790--1801},
  issn = {2150-8097},
  doi = {10.14778/2367502.2367518},
  urldate = {2025-06-16},
  abstract = {This paper describes the system architecture of the Vertica Analytic Database (Vertica), a commercialization of the design of the C-Store research prototype. Vertica demonstrates a modern commercial RDBMS system that presents a classical relational interface while at the same time achieving the high performance expected from modern "web scale" analytic systems by making appropriate architectural choices. Vertica is also an instructive lesson in how academic systems research can be directly commercialized into a successful product.},
  langid = {english},
  annotation = {TLDR: Vertica demonstrates a modern commercial RDBMS system that presents a classical relational interface while at the same time achieving the high performance expected from modern "web scale" analytic systems by making appropriate architectural choices.},
  file = {D:\zotero-storage\storage\C7NTJHFY\Lamb 等 - 2012 - The vertica analytic database C-store 7 years later.pdf}
}

@article{oneilLogstructuredMergetreeLSMtree1996,
  title = {The Log-Structured Merge-Tree ({{LSM-tree}})},
  author = {O'Neil, Patrick and Cheng, Edward and Gawlick, Dieter and O'Neil, Elizabeth},
  year = {1996},
  month = jun,
  journal = {Acta Inf.},
  volume = {33},
  number = {4},
  pages = {351--385},
  issn = {0001-5903},
  doi = {10.1007/s002360050048},
  urldate = {2025-06-16},
  abstract = {High-performance transaction system applications typically insert rows in a History table to provide an activity trace; at the same time the transaction system generates log records for purposes of system recovery. Both types of generated information can benefit from efficient indexing. An example in a well-known setting is the TPC-A benchmark application, modified to support efficient queries on the history for account activity for specific accounts. This requires an index by account-id on the fast-growing History table. Unfortunately, standard disk-based index structures such as the B-tree will effectively double the I/O cost of the transaction to maintain an index such as this in real time, increasing the total system cost up to fifty percent. Clearly a method for maintaining a real-time index at low cost is desirable. The log-structured mergetree (LSM-tree) is a disk-based data structure designed to provide low-cost indexing for a file experiencing a high rate of record inserts (and deletes) over an extended period. The LSM-tree uses an algorithm that defers and batches index changes, cascading the changes from a memory-based component through one or more disk components in an efficient manner reminiscent of merge sort. During this process all index values are continuously accessible to retrievals (aside from very short locking periods), either through the memory component or one of the disk components. The algorithm has greatly reduced disk arm movements compared to a traditional access methods such as B-trees, and will improve cost-performance in domains where disk arm costs for inserts with traditional access methods overwhelm storage media costs. The LSM-tree approach also generalizes to operations other than insert and delete. However, indexed finds requiring immediate response will lose I/O efficiency in some cases, so the LSM-tree is most useful in applications where index inserts are more common than finds that retrieve the entries. This seems to be a common property for history tables and log files, for example. The conclusions of Sect. 6 compare the hybrid use of memory and disk components in the LSM-tree access method with the commonly understood advantage of the hybrid method to buffer disk pages in memory.},
  langid = {english},
  annotation = {TLDR: The log-structured mergetree (LSM-tree) is a disk-based data structure designed to provide low-cost indexing for a file experiencing a high rate of record inserts (and deletes) over an extended period.},
  file = {D:\zotero-storage\storage\RFF89UWZ\O’Neil 等 - 1996 - The log-structured merge-tree (LSM-tree).pdf}
}
